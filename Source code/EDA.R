#Project Name: Studing the Dementia Caregiver Sleep
#File Name: Computing the EDA features based on the different papers referenced in the paper
#Author: Reza Sadeghi
#Email: sadeghi.2@wright.edu; reza@knoesis.org
#Ver:1.1
#Last modification:6/26/2018
#With special thanks to Garrett Goodman (goodman.27@wright.edu)
#This function needs to R.matlab and local octave or matlab set up in the local machine

#>>> computing rRR time series with sliding windows of
#windows (windowsLength) with moving (stepLength)

EDA<-function(originalACC, originalEDA){

#>>>>>>> connecting to the local matlab
#install.packages("R.matlab")
# library(R.matlab)
# Matlab$startServer()
# matlab <- Matlab()
# isOpen <- open(matlab)
# print(matlab)

#>>>>>> coles function
#set variable
#originalACC <- data[[1]][[1]][[1]]$ACC
originalACC <- as.matrix(originalACC)
setVariable(matlab, originalACC=originalACC)

#originalEDA <- data[[1]][[1]][[1]]$EDA
originalEDA <- as.matrix(originalEDA)
setVariable(matlab, originalEDA=originalEDA)

#run the function and get the outputs
code <- c(
  "function [outputMatrix]=Coles_Function(originalACC)",
  "% Load the csv file and create variables",
  "samplingRate=originalACC(2)/2;",
  "samplingRate = originalACC(2) / 2;",
  "originalACC = originalACC([3:end], :);",
  "size = floor(length(originalACC) / 2);",
  "outputMatrix = ones(floor((((size) / samplingRate) / 60)), 1);",
  "zcd = dsp.ZeroCrossingDetector;",
  "",
  "% Smooth from 32 to 16 Hz",
  "downSampledACC = zeros((size), 3);",
  "meanVar = 0;",
  "i = 0;",
  "j = 1;",
  "for x = (1:length(originalACC))",
  "    if (j == ((size) + 1))",
  "        break;",
  "    end",
  "    meanVar = meanVar + originalACC(x, :);",
  "    i = i + 1;",
  "    if (i == 2)",
  "        meanVar = meanVar / 2;",
  "        downSampledACC(j, :) = meanVar;",
  "        i = 0;",
  "        j = j + 1;",
  "        meanVar = 0;",
  "    end",
  "end",
  "",
  "% Variables specific to coles function",
  "startingEpoch = 1;",
  "endingEpoch = 10;",
  "activityMatrix = zeros(7, 1);",
  "",
  "% Peform the calculations of the cole function",
  "for k = 5:(length(outputMatrix) - 4)",
  "    currentPosition = ((k * 60) * samplingRate);",
  "    matrixPointer = 1;",
  "    for z = -4:2",
  "        largestEpoch = 0;",
  "        tempCurrentPosition = currentPosition + (z * samplingRate * 60);",
  "        for i = 1:26",
  "            tempPosition = 0;",
  "            if i == 1",
  "                tempPosition = tempCurrentPosition;",
  "            else",
  "                tempPosition = tempCurrentPosition + (startingEpoch * samplingRate);",
  "            end",
  "            tempMatrix = downSampledACC(tempPosition:(tempPosition + (endingEpoch * samplingRate)), :);",
  "            % Use zero crossing algorithm to calculate wrist activity",
  "            tempValue = sum(step(zcd, tempMatrix));",
  "            if tempValue > largestEpoch",
  "                largestEpoch = tempValue;",
  "            end",
  "            zcd.release();",
  "            ",
  "            startingEpoch = startingEpoch + 2;",
  "            endingEpoch = endingEpoch + 2;",
  "        end",
  "        activityMatrix(matrixPointer) = largestEpoch;",
  "        startingEpoch = 1;",
  "        endingEpoch = 10;",
  "        matrixPointer = matrixPointer + 1;",
  "        largestEpoch = 0;",
  "    end",
  "    ",
  "    % Determine if minute is asleep or awake",
  "    awakeAsleep = -1;",
  "    D = 0.00001 * ((404 * activityMatrix(1, 1)) + (598 * activityMatrix(2, 1)) + (326 * activityMatrix(3, 1)) + (441 * activityMatrix(4, 1)) + (1408 * activityMatrix(5, 1)) + (508 * activityMatrix(6, 1)) + (350 * activityMatrix(7, 1)));",
  "    if D < 1",
  "        awakeAsleep = 0;",
  "    else",
  "        awakeAsleep = 1;",
  "    end",
  "    outputMatrix(k) = awakeAsleep;",
  "    activityMatrix = zeros(7, 1);",
  "end",
  "",
  "% Implement rescoring",
  "% Rule A",
  "i = 4;",
  "while i < (length(outputMatrix))",
  "    if ((outputMatrix((i - 3):i) == 1) & (outputMatrix(i + 1) == 1))",
  "        i = i + 1;",
  "    elseif (outputMatrix((i - 3):i) == 1)",
  "        outputMatrix(i + 1) = 1;",
  "        i = i + 5;",
  "    else",
  "        i = i + 1;",
  "    end",
  "end",
  "",
  "% Rule B",
  "i = 10;",
  "while i < (length(outputMatrix))",
  "    if ((outputMatrix((i - 9):i) == 1) & (outputMatrix(i + 1) == 1))",
  "        i = i + 1;",
  "    elseif (outputMatrix((i - 9):i) == 1)",
  "        outputMatrix(i + 1) = 1;",
  "        i = i + 11;",
  "    else",
  "        i = i + 1;",
  "    end",
  "end",
  "",
  "% Rule C",
  "i = 15;",
  "while i < (length(outputMatrix))",
  "    if (outputMatrix((i - 14):i) == 1  & (outputMatrix(i + 1) == 1))",
  "        i = i + 1;",
  "    elseif (outputMatrix((i - 9):i) == 1)",
  "        outputMatrix(i + 1) = 1;",
  "        i = i + 16;",
  "    else",
  "        i = i + 1;",
  "    end",
  "end",
  "",
  "% Rule D (Can be optimized)",
  "i = 1;",
  "while i < (length(outputMatrix))",
  "    if (outputMatrix(i) == 1)",
  "        position = i;",
  "        tempPosition = i;",
  "        if(tempPosition == length(outputMatrix))",
  "            break;",
  "        end",
  "        oneCounter = 0;",
  "        while (outputMatrix(tempPosition) == 1)",
  "            if(tempPosition == length(outputMatrix))",
  "                break;",
  "            end",
  "            tempPosition = tempPosition + 1;",
  "            oneCounter = oneCounter + 1;",
  "        end",
  "        zeroCounter = 0;",
  "        if (oneCounter >= 10)",
  "            while (outputMatrix(tempPosition) == 0)",
  "                if(tempPosition == length(outputMatrix))",
  "                    break;",
  "                elseif (zeroCounter > 6)",
  "                    break;",
  "                end",
  "                tempPosition = tempPosition + 1;",
  "                zeroCounter = zeroCounter + 1;",
  "            end",
  "        end",
  "        oneCounter = 0;",
  "        if (zeroCounter <= 6) & (zeroCounter > 0)",
  "            while (outputMatrix(tempPosition) == 1)",
  "                if(tempPosition == length(outputMatrix))",
  "                    break;",
  "                end",
  "                tempPosition = tempPosition + 1;",
  "                oneCounter = oneCounter + 1;",
  "            end",
  "        end",
  "        endPosition = tempPosition;",
  "        if (oneCounter >= 10)",
  "            outputMatrix(position:endPosition) = 1;",
  "            i = endPosition;",
  "        end",
  "    end",
  "    i = i + 1;",
  "end",
  "",
  "end"
)

setFunction(matlab, code)
#evaluate(matlab, "[outputMatrix]=Coles_Function(originalACC);")

#>>>>>> Signal processing and other EDA characteristics
code <- c(
  "function [amountAsleep, amountAwake, sleepEfficiency, timesAwoken, epochCapacity, epochPeak, epochPeakCounter, stormPeak, largestStorm, timesEdaStorm, meanEdaStorm, lengthEdaStorm]=EDA_Function(originalACC, originalEDA) ",
  "	",
  "	samplingRateEDA=originalEDA(2);",
  "    %currentNight=originalEDA(1);",
  "    originalEDA=originalEDA([3:end], :); % EDA Matrix without first two rows",
  "    edaSize=length(originalEDA); % Size of the EDA Matrix without first two rows",
  "    ",
  "    % Load ACC, apply Cole's Function to it",
  "    %originalACC=csvread(accCSV);",
  "    %sleepAwakeMatrix=Coles_Function(accCSV);",
  "    sleepAwakeMatrix=Coles_Function(originalACC);",
  "    %disp(length(sleepAwakeMatrix))",
  "    ",
  "    % Remove all EDA data where determination is awake",
  "    newEDA=[];",
  "    for i=1:length(sleepAwakeMatrix)",
  "        if (sleepAwakeMatrix(i)==0)",
  "            newEDA=[newEDA; originalEDA((i * samplingRateEDA * 60):((i + 1) * samplingRateEDA * 60))];",
  "        end",
  "    end",
  "    ",
  "    % Apply 32nd order, 4Hz FIR(Frequency Impulse Response) filter",
  "    newEDA=transpose(newEDA);",
  "    %newEDA=transpose(originalEDA);",
  "    bhi=fir1(32, 0.4); ",
  "    filteredEDA=filter(bhi, 1, newEDA);",
  "    ",
  "    % Calculate first derivative of filtered EDA",
  "    derMatrix=[];",
  "    filteredEDA=transpose(filteredEDA);",
  "    for i=2:length(newEDA)",
  "        derMatrix=[derMatrix; ((filteredEDA(i) - filteredEDA(i - 1))/.25)];",
  "    end",
  "    ",
  "    % Calculate EDA Peaks per second",
  "    peakMatrix=zeros(length(derMatrix), 1); % Use for EDA Event Feature",
  "    edaEventCounter=0;",
  "    i=1;",
  "    while( i <= length(derMatrix))",
  "        if (derMatrix(i) > 0.01) ",
  "            peakMatrix(i)=1;",
  "            edaEventCounter=edaEventCounter + 1;",
  "            % Based on the paper of [Quantitative analysis of wrist",
  "            % electrodermal activity during sleep], Peaks must be separated",
  "            % by at least one second or they will be counted as a single",
  "            % peak",
  "            i=i+3;",
  "        end",
  "        i=i+1;",
  "    end",
  "    ",
  "    secondMatrix=zeros(floor(length(peakMatrix) / samplingRateEDA), 1);",
  "    k=1;",
  "    j=samplingRateEDA;",
  "    while (j < length(peakMatrix))",
  "        if (ismember(1, peakMatrix((j - (samplingRateEDA-1)):j)))",
  "            secondMatrix(k)=1;",
  "        end",
  "        k=k + 1;",
  "        j=j + samplingRateEDA;",
  "    end",
  "    ",
  "    % Detect all 30 second EDA Epochs",
  "    epochMatrix=zeros(floor(length(secondMatrix) / 30), 1);",
  "    epochPeakCounter=0;",
  "    k=1;",
  "    j=30;",
  "    while (j < length(secondMatrix))",
  "        if (ismember(1, secondMatrix((j - 29):j)))",
  "            epochMatrix(k)=sum(secondMatrix((j - 29):j));",
  "            epochPeakCounter=epochPeakCounter + 1;",
  "        end",
  "        k=k + 1;",
  "        j=j + 30;",
  "    end",
  "    ",
  "    % Detect all EDA Storms",
  "    % Showing as list of EDA Storms and their corresponding sizes",
  "    edaStormMatrix=[];",
  "    edaEpochStorm=0;",
  "    i=1;",
  "    while i < length(epochMatrix)",
  "        if (epochMatrix(i) >= 1)",
  "            z=i;",
  "            tempCounter=0;",
  "            epochSotrm=0;",
  "            while (epochMatrix(z) >= 1)",
  "                if (z==length(epochMatrix))",
  "                    break;",
  "                end",
  "                tempCounter=tempCounter + 1;",
  "                epochSotrm=epochSotrm+epochMatrix(z);",
  "                z=z + 1;",
  "            end",
  "            if (tempCounter >= 2)",
  "                edaStormMatrix=[edaStormMatrix; tempCounter];",
  "                edaEpochStorm=edaEpochStorm+epochSotrm;",
  "            end",
  "            i=z;",
  "        end",
  "        i=i + 1;",
  "    end",
  "    ",
  "    % Calculate Sleep Efficiency",
  "    totalTimeInBed=((edaSize / 4) / 60);",
  "    totalTimeAsleep=((length(newEDA) / 4) / 60);",
  "    sleepEfficiency=totalTimeAsleep/totalTimeInBed;",
  "    ",
  "    % Some Results",
  "    ",
  "    amountAwake=0;",
  "    amountAsleep=0;",
  "    timesAwoken=0;",
  "    for i=1:length(sleepAwakeMatrix)",
  "        if(sleepAwakeMatrix(i)==1)",
  "            amountAwake=amountAwake + 1;",
  "            if((i>1) && (sleepAwakeMatrix(i-1)==0))",
  "                timesAwoken=timesAwoken+1;",
  "            end",
  "        else",
  "            amountAsleep=amountAsleep + 1;",
  "        end",
  "    end",
  "    ",
  "    largestStorm=0;",
  "    for i=1:length(edaStormMatrix)",
  "        if (edaStormMatrix(i) > largestStorm)",
  "            largestStorm=edaStormMatrix(i);",
  "        end",
  "    end",
  "	",
  "	timesEdaStorm=length(edaStormMatrix);",
  "	meanEdaStorm=mean(edaStormMatrix);",
  "	%stdEdaStorm=std(edaStormMatrix);",
  "    lengthEdaStorm=sum(edaStormMatrix);",
  "	",
  "    epochCapacity=sum(epochMatrix>1)/length(epochMatrix);",
  "    epochPeak=mean(epochMatrix(find(epochMatrix>0)));",
  "    stormPeak=(edaEpochStorm/sum(epochMatrix));",
  "end"
)

setFunction(matlab, code)
evaluate(matlab, "[amountAsleep, amountAwake, sleepEfficiency, timesAwoken, epochCapacity, epochPeak, epochPeakCounter, stormPeak, largestStorm, timesEdaStorm, meanEdaStorm, lengthEdaStorm]=EDA_Function(originalACC, originalEDA);")
output <- getVariable(matlab, c("amountAsleep", "amountAwake", "sleepEfficiency", "timesAwoken", "epochCapacity", "epochPeak", "epochPeakCounter", "stormPeak", "largestStorm", "timesEdaStorm", "meanEdaStorm", "lengthEdaStorm"))

returnList <- output
return(returnList)
}